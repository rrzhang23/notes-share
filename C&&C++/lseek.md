* **<font color=#FF0000> `lseek` 为进程独享, 线程共享</font>**

函数定义：
```cpp
#include<unistd.h>
off_t lseek (int __fd, __off_t __offset, int __whence) __THROW;
```

__whence有以下几种值：
1. 若 `whence` 是 `SEEK_SET` ，则文件偏移量设置为距文件开始处 `offset` 个字节。
2. 若 `whence` 是 `SEEK_CUR`，则文件偏移量设置为当前值加  `offset` ，`offset` 可为正或负。
3. 若 `whence` 是 `SEEK_END` ，则文件偏移量设置为文件长度加 `offset`，`offset` 可为正或负。

 文件偏移量可以大于文件的当前长度，在这种情况下，对该文件的下一次写将加长该文件，并在文件中构成一个空洞。位于文件中但没有写过的字节都被读为0。
文件中的空洞不要求在磁盘上占用存储区。当定位到超出文件尾端之后写时，对于新写的数据需要分配磁盘块，但是对于原文件尾端和新开始位置之间的部分则不需要分配磁盘块。

**lseek返回值，当调用成功，返回值是距离文件开始的偏移量，否则为错误代码**

[参考链接](https://www.cnblogs.com/ly01/p/4597926.html)

今天在测试在读写中插入 lseek 时，发现一些有趣的东西。  
默认写是直接追加在最后的。  
当我们用
```
    open(open_path.c_str(), O_RDWR | O_CREAT, 0644);
```
即不带 O_APPEND 参数打开文件时，文件游标（lseek指向的位置是0），这时候写入时从 0 处开始写，会覆盖数据。  
lseek 设置到哪里，相应的读写位置就从哪里开始，且读写完后游标会相应后移。

需要注意的几点：
1. read正常返回读到的实际字节，但是正好读到文件尾时，返回值是0。
2. `cout<<lseek(fd, 0, SEEK_CUR)<<endl;` 可以知道当前游标位置。
3. 但是，按理说通过 O_APPEND 打开的文件，游标应该在文件尾了，但是不是的，还是在文件头部，除非经过第一次读写后，才会正常。